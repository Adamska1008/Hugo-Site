---
title: '读论文：LLVM: a compilation framework for lifelong program analysis & transformation'
date: 2024-07-09T20:50:02+08:00
draft: true
author: Zijian Zang
UseHugoToc: true
tags: 
 - Compilers
 - LLVM
---

<!--more-->

LLVM的提出者认为，程序分析与转化有必要在程序的整个生命周期中进行，既是为了程序优化，也是为了灵活集成其他工具。LLVM旨在通过一种新的中间语言和编译器实现，来达成这一目标。LLVM中间码是一种类RISC语言，但有着更高级的信息（为了程序分析），例如类型信息、控制流图、数据流。LLVM中间码具有独立的一套类型系统，能够用于实现高级语言的类型；同时其具有能够保存类型信息的计算操作。LLVM中间码还具有两个的异常处理指令，用来实现高级语言中的异常机制。除此之外，LLVM中间码提供了一套内存抽象系统。

基于LLVM中间码，LLVM编译框架能够提供一系列功能，包括：

1. 存在于程序完整生命周期的编译模型。以此，可以在程序的任何一个阶段进行优化，包括运行阶段，交互阶段。
2. 离线代码生成。依然可以生成优化激进的，性能强的代码。尽管这意味着无法生成运行时代码。
3. 基于用户的性能分析和优化。LLVM框架可以在运行时收集分析信息，
4. 透明的运行时模型，没有使用对象、异常语法或运行时环境，任何语言都能编译为LLVM中间码。
5. 独立于语言，程序可以集成多语言编写的代码，编译为统一的中间码。

LLVM致力优化三个方面：1. 中间码的体积与性能。2. 编译器的表现。3. 提供一些示例，用于展现LLVM解决挑战性问题的能力。

### LLVM中间码

LLVM中间码的核心创新点在于：1. LLVM类型系统与`getelementptr`指令。2. LLVM内存模型。3. `invoke`与`unwind`指令，用于实现异常处理。

LLVM指令集描述了处理器的原始操作，但是避免提及硬件规范，例如寄存器、流水线。LLVM提供了**无限的带类型虚拟寄存器**，可以保存原始类型如：布尔（boolean）、整型（integer）、浮点数（floating point）和指针（pointers）。虚拟寄存器使用**SSA**（Static Single Assignment）形式进行计算。LLVM使用**load/store结构**，这意味着内存访问指令和算术、逻辑指令分开处理。load/store指令基于有类型的指针来进行。

LLVM指令集（在论文发表时，2003年）只有31个操作符。这是因为：1. LLVM避免实现功能相同的操作码，例如用xor取代not。2. 大多数操作符支持重载，例如`add`可以适用于整型或浮点型。大多数指令（算术和逻辑运算）为**三地址码**（Three-address code，TAC）。

为了实现SSA，LLVM提供了`phi`指令用来实现&Phi;算符。LLVM也使得每个函数都可以明确地以控制流图来表示。

#### 类型系统

每个SSA寄存器和内存对象都有一个关联类型。额外的类型信息实现了操作符的重载，也有助于帮助实现一些高级代码的转化和优化。除了原始类型，LLVM也提供了四种可派生类型：指针（pointer）、数组（array）、结构体（structure）和函数（function）。作者认为大部分高级语言的数据类型最终都是用这些可派生类型来表示的。

`cast`指令用于将转化值到任意类型，它是唯一一种转换类型的方式。尽管转换类型是任意的，类型信息整体来说依然是可靠的。

地址运算是另一大难题。`getelementptr`指令用于实现类型安全的地址运算。该指令用于获取指向某对象的子字段的指针。例如，给定一个数组指针和一个偏移量数字，该指令将返回指向对应元素的指针。由于Load/Store指令只接受一个指针，故该指令使得访存简便许多。

#### 显示内存分配和统一内存模型

LLVM提供了带类型的内存分配指令`malloc`，它在堆区内存分配一个或多个指定类型的元素，返回一个指向该内存的带类型信息的指针。`free`指令用于释放内存。

## 参考文献
