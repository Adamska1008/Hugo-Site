---
title: '读论文：Understanding Integer Overflow in C/C++'
date: 2024-04-03T00:52:46+08:00
draft: true
author: Zijian Zang
UseHugoToc: true
tags: 
 - C++
---

本文不会整篇翻译论文，只会从论文提供的内容中摘录一些比较感兴趣的内容。

<!--more-->

虽然大部分人都清楚整型溢出是什么，但实际上它可能比我们想象的还要复杂。由于C/C++规范对`int`类型的约束甚少，不仅没有规定它可以表达的范围，甚至没有规定它是否必须用二进制补码表示。因此，`int`类型中许多操作实质上都是*undefined behaviour*，尽管我们很熟悉它会如何溢出，甚至已经利用这一溢出实现了一些功能，例如哈希或密码学方面的功能。

由于C/C++存在这种*undefined behaviour*，因此我们可能在无意识中编写出依赖于平台或编译器的，不可移植的代码。理论上，C99标准下`int`并非必须能表达大于2\^15-1的数，但我们一般都将`int`的范围视作-2\^31~2^31-1。

即使明确定义的规范也可能存在一定的陷阱。例如`0U-1`规定必须为`UINT_MAX`，然而`UINT_MAX`的数值有明确规定吗？答案是没有。如果想当然的写出`assert(0U-1 == 4294967296)`就有可能会导致错误。

编译器对于UB的不同处理方式可能导致不符合预期的结果。例如在Google的一次重构中，一次安全检查内部直接使用了`1<<32`表达式，而编译器优化了这个表达式为不执行任何操作（nop），故使得安全检查没有检查出整型溢出的问题。又如，形如下的程序。

```c++
int foo(int x)
{
    return (x + 1) > x;
}

int main()
{
    printf("%d", (INT_MAX+1) > INT_MAX);
    printf("%d", foo(INT_MAX));
}
```

在GCC、LLVM、MSVC开启`-O2`优化后，前者输出`0`，这是整型溢出造成的；而后者输出`1`，因为编译器将`foo`函数调用优化为`1`。由于`INT_MAX+1`并没有被规定为必须为`INT_MIN`，它可以被解释为任意值，因此这一优化仍然是合法的。

正如上文中提到的情况，对于UB，编译器不一定会做出最*合理*的推测。例如，当开启优化后，编译器可能倾向于做出最优于性能的优化。

有些编译器支持更强的语义。例如GCC与Clang支持编译参数`-fwrapv`，使得整型溢出必定表现为二进制补码溢出的形式。例如，对于上文的代码示例，加入该参数后二者输出都为`0`。

## 参考文献

[1] Will Dietz, Peng Li, John Regehr, Vikram Adve. Understanding Integer Overflow in C/C++.
